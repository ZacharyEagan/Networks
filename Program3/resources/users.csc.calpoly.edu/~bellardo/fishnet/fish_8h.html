<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Fishnet: fish.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>fish.h File Reference</h1><code>#include &lt;stdlib.h&gt;</code><br/>
<code>#include &lt;unistd.h&gt;</code><br/>
<code>#include &lt;stdio.h&gt;</code><br/>
<code>#include &lt;sys/types.h&gt;</code><br/>
<code>#include &lt;netinet/in.h&gt;</code><br/>

<p><a href="fish_8h_source.html">Go to the source code of this file.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfn__l2addr__t.html">fn_l2addr_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The type definition for a fishnet L2 address.  <a href="structfn__l2addr__t.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_fishnet_l2_funcs.html">FishnetL2Funcs</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Functions for transmitting and receiving L2 frames.  <a href="struct_fishnet_l2_funcs.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_fishnet_l3_funcs.html">FishnetL3Funcs</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Functions for sending and receiving layer 3 frames.  <a href="struct_fishnet_l3_funcs.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_fishnet_l4_funcs.html">FishnetL4Funcs</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Layer 4 frame handling functions.  <a href="struct_fishnet_l4_funcs.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfishnet__arp__functions.html">fishnet_arp_functions</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Functions for interacting with the ARP cache and resolving L3 addresses into L2 addresses.  <a href="structfishnet__arp__functions.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfishnet__fwtable__functions.html">fishnet_fwtable_functions</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A structure that contains function pointers for all fowarding table operations, such as lookup and insertion.  <a href="structfishnet__fwtable__functions.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfishnet__fcmp__functions.html">fishnet_fcmp_functions</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A structure that contains function pointers for all FCMP related operations.  <a href="structfishnet__fcmp__functions.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfishnet__name__functions.html">fishnet_name_functions</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Functions and declarations that interact with the built-in name protocol implementation. Modifing these function pointers allows you to provide your own implementation.  <a href="structfishnet__name__functions.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfishnet__lsa__functions.html">fishnet_lsa_functions</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The LSA implementation is current incomplete! Functions, structures, and constants that relate to the built-in implementation of the link state routing algorithm.  <a href="structfishnet__lsa__functions.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="fish_8h.html#af580f1123d8e17a73f75aae203601d68">IPTR_FMT</a>&nbsp;&nbsp;&nbsp;&quot;d&quot;</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="fish_8h.html#aff3dbff84d5ac014bdbe6d62a4541b7a">UIPTR_FMT</a>&nbsp;&nbsp;&nbsp;&quot;u&quot;</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___l2.html#gab57b16e9100cc5ae9631a2a82519caa0">FNL2_EQ</a>(x, y)&nbsp;&nbsp;&nbsp;(0 == memcmp(&amp;(x).l2addr, &amp;(y).l2addr, sizeof((x).l2addr)))</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A macro that tests fishnet layer 2 addresses for equality.  <a href="group___l2.html#gab57b16e9100cc5ae9631a2a82519caa0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___l2.html#gaf1eb9eb5c409012cc272dbf6eb7859f9">FNL2_VALID</a>(x)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A macro that tests the validity of a fishnet layer 2 address.  <a href="group___l2.html#gaf1eb9eb5c409012cc272dbf6eb7859f9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___l3.html#ga843f582b945ff08ad64483d574123502">ALL_NEIGHBORS</a>&nbsp;&nbsp;&nbsp;htonl(0xFFFFFFFF)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This Fishnet address allows you use fish_send() to send a frame to all immediate neighbors.  <a href="group___l3.html#ga843f582b945ff08ad64483d574123502"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___l1.html#ga0ff29830fde482fdf175988774b78edb">MTU</a>&nbsp;&nbsp;&nbsp;1500</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Packet size limits. The total packet length must be less than the maximum transmission unit (MTU).  <a href="group___l1.html#ga0ff29830fde482fdf175988774b78edb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___l3.html#ga7224cc1e84435ca6a8da91c22295d1b2">MAX_TTL</a>&nbsp;&nbsp;&nbsp;64</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The time-to-live or TTL limits the number of hops a packet can take, in order to prevent loops.  <a href="group___l3.html#ga7224cc1e84435ca6a8da91c22295d1b2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__debug.html#ga95fa0b25789d0a4443642a69a4b1dd43">FISH_DEBUG_NONE</a>&nbsp;&nbsp;&nbsp;0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">No debugging messages.  <a href="group__debug.html#ga95fa0b25789d0a4443642a69a4b1dd43"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__debug.html#gac4bbaa525a9e9fd8fa06addbb087b482">FISH_DEBUG_APPLICATION</a>&nbsp;&nbsp;&nbsp;1</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print debug messages from the application(s) (L7).  <a href="group__debug.html#gac4bbaa525a9e9fd8fa06addbb087b482"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__debug.html#ga67b5f0c999bcd59427f21b3a518bdaa1">FISH_DEBUG_USER1</a>&nbsp;&nbsp;&nbsp;2</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A debug level for your own use.  <a href="group__debug.html#ga67b5f0c999bcd59427f21b3a518bdaa1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__debug.html#ga7739b78c98342f0abcadf07569022d1a">FISH_DEBUG_TRANSPORT</a>&nbsp;&nbsp;&nbsp;3</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Debug messages for transport level events (L4).  <a href="group__debug.html#ga7739b78c98342f0abcadf07569022d1a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__debug.html#ga6659cf6041f4dc37d1a6b38338cb57d1">FISH_DEBUG_USER2</a>&nbsp;&nbsp;&nbsp;4</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A debug level for your own use.  <a href="group__debug.html#ga6659cf6041f4dc37d1a6b38338cb57d1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__debug.html#ga358145f2390d48a616ead167b3511993">FISH_DEBUG_ROUTING</a>&nbsp;&nbsp;&nbsp;5</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Debug level that includes routing messages (L3).  <a href="group__debug.html#ga358145f2390d48a616ead167b3511993"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__debug.html#ga91914e3055000dcc99de480730fbd606">FISH_DEBUG_TOPOLOGY</a>&nbsp;&nbsp;&nbsp;6</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Debug level that incudes topology changes from fishhead.  <a href="group__debug.html#ga91914e3055000dcc99de480730fbd606"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__debug.html#ga213bf26232ae479bc462a1f04feb9a1d">FISH_DEBUG_ALL</a>&nbsp;&nbsp;&nbsp;7</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Debug level that includes everything.  <a href="group__debug.html#ga213bf26232ae479bc462a1f04feb9a1d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__debug.html#gaaa02ed7a7e0231f6f1c46e03f678f514">FISH_DEBUG_INTERNAL</a>&nbsp;&nbsp;&nbsp;8</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Debug level that includes internal fishnet debugging messages.  <a href="group__debug.html#gaaa02ed7a7e0231f6f1c46e03f678f514"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_w_d.html#gad8f4bad74bf4a3cf2b68383bf701ebcf">FISH_FWD_TYPE_CONNECTED</a>&nbsp;&nbsp;&nbsp;'C'</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The type constant for a directly connected route.  <a href="group___f_w_d.html#gad8f4bad74bf4a3cf2b68383bf701ebcf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_w_d.html#ga9d399caf631df98e3cc0f2d2cc0ba600">FISH_FWD_TYPE_LOOPBACK</a>&nbsp;&nbsp;&nbsp;'L'</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The type constant for a loopback route.  <a href="group___f_w_d.html#ga9d399caf631df98e3cc0f2d2cc0ba600"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_w_d.html#ga735cad98d545f8f5336b6474c2f60a24">FISH_FWD_TYPE_BROADCAST</a>&nbsp;&nbsp;&nbsp;'B'</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The type constant for a broadcast route.  <a href="group___f_w_d.html#ga735cad98d545f8f5336b6474c2f60a24"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_w_d.html#ga83c1e7601980e84b2468574df65be5de">FISH_FWD_TYPE_DV</a>&nbsp;&nbsp;&nbsp;'D'</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The type constant for a distance-vector route.  <a href="group___f_w_d.html#ga83c1e7601980e84b2468574df65be5de"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_w_d.html#ga560bd15eade4a6d593711f3ef85b238c">FISH_FWD_TYPE_LS</a>&nbsp;&nbsp;&nbsp;'Z'</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The type constant for a link-state route.  <a href="group___f_w_d.html#ga560bd15eade4a6d593711f3ef85b238c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_w_d.html#ga302c3f18d2036578d081ddbcdb3dcb74">FISH_FWD_TYPE_NEIGHBOR</a>&nbsp;&nbsp;&nbsp;'N'</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The type constant for routes learned through the neighbor protocol.  <a href="group___f_w_d.html#ga302c3f18d2036578d081ddbcdb3dcb74"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="fish_8h.html#a95423e01c84b7e7d0833542a9029790a">NEIGHBOR_USE_LIBFISH_NEIGHBOR_DOWN</a>&nbsp;&nbsp;&nbsp;0x01</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Permits the built-in neighbor protocol to use the "neighbor down" information provided by libfish. This is the exact same information provided to the 'neighbor_down_handler_t' as documented below. This option does not impact discovering neighbors. That still takes place via broadcast frames as described in the fishnet spec. Use of this option causes most (but not all) neighbor departures to be detected immediately. Not using this option requires a full timeout before detecting a neighbor has left the network.  <a href="#a95423e01c84b7e7d0833542a9029790a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="fish_8h.html#a9da208c5068204dc49fa6c59eef27718">DVROUTING_TRIGGERED_UPDATES</a>&nbsp;&nbsp;&nbsp;0x01</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If present, enable triggered updates in the built-in implementation. Triggered updates create a much higher network load, especially in larger networks. They can also make it hard to follow what is happening since the updates fly by quickly. Passing a value of 0 disables triggered updates. Passing any other value enables them.  <a href="#a9da208c5068204dc49fa6c59eef27718"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="fish_8h.html#a10b5eaf044a18b5feb88127f077266b3">DVROUTING_WITHDRAW_ROUTES</a>&nbsp;&nbsp;&nbsp;0x02</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If present, enable route withdraws. When using route withdraws, the dv code will advertise all withdrawn route with a metric of infinity. If route withdraws are not used then invalid routes will immediately leave the dv state.  <a href="#a10b5eaf044a18b5feb88127f077266b3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="fish_8h.html#a5918fd6126ce72175c6cef916484eba6">RVROUTING_USE_LIBFISH_NEIGHBOR_DOWN</a>&nbsp;&nbsp;&nbsp;0x04</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Permits the built-in dv routing solution to use the "neighbor down" information provided by libfish. This is the exact same information provided to the 'neighbor_down_handler_t' as documented below. This option does not impact discovering neighbors. That still takes place via DV frames as described in the fishnet spec. Use of this option causes most (but not all) neighbor departures to be detected immediately. Not using this option requires a full timeout before detecting a neighbor has left the network.  <a href="#a5918fd6126ce72175c6cef916484eba6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="fish_8h.html#aa4f1786ab3107fd95c808f6b4be105e6">DVROUTING_SPLIT_HOR_POISON_REV</a>&nbsp;&nbsp;&nbsp;0x08</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enable split horizion with poison reverse. Using this option increases resiliency against counting to infinity problems, but also increases the amount of routing traffic on the network.  <a href="#aa4f1786ab3107fd95c808f6b4be105e6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="fish_8h.html#a1dff069634154ca489b6912fc961da79">DVROUTING_KEEP_ROUTE_HISTORY</a>&nbsp;&nbsp;&nbsp;0x10</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enables route history in the built-in dv implementation. Non-optimal routes are kept as "backups" in case the primary route fails. This option tends to speed route convergance when there is churn in the network.  <a href="#a1dff069634154ca489b6912fc961da79"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="fish_8h.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a>&nbsp;&nbsp;&nbsp;(0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="fish_8h.html#aa8cecfc5c5c054d2875c03e77b7be15d">TRUE</a>&nbsp;&nbsp;&nbsp;(!FALSE)</td></tr>
<tr><td colspan="2"><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___l3.html#ga56eb193582cf90391b0719f7ec51bde1">fnaddr_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The type definition for a fishnet L3 address.  <a href="group___l3.html#ga56eb193582cf90391b0719f7ec51bde1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="fish_8h.html#aa45b58a003ff36d7802685330bff26fb">keyboard_handler</a> )(char *line_of_text)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">keyboard_handler is the type of the upcall registered with <a class="el" href="fish_8h.html#a3268fee39255dddc739984b312a9068f" title="fish_keybhook registers a function that you write to be called at a later time when...">fish_keybhook()</a>. Your keyboard input handler will take one parameter: *line_of_text*, which does not include the newline character ('<br/>
'), but is null-terminated so that functions like sprintf will work.  <a href="#aa45b58a003ff36d7802685330bff26fb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="fish_8h.html#afb544cef80537f1a18297eda61234a2b">event_handler_t</a> )(void *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">fish_scheduleevent sets up a timer function to be called at some time in the future.  <a href="#afb544cef80537f1a18297eda61234a2b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef intptr_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="fish_8h.html#a02497580bb9dbdffe44b2eaaefdf9176">event</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_r_p.html#ga29e21b98d1d024b2d67edb363b7bba4e">arp_resolution_cb</a> )(<a class="el" href="structfn__l2addr__t.html">fn_l2addr_t</a> addr, void *param)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function signature for the ARP resolution callback.  <a href="group___a_r_p.html#ga29e21b98d1d024b2d67edb363b7bba4e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_w_d.html#gad76a3743f2c2e2786f4e1d67967f9ebb">fwtable_iterator_cb</a> )(void *callback_data, <a class="el" href="group___l3.html#ga56eb193582cf90391b0719f7ec51bde1">fnaddr_t</a> dest, int prefix_len, <a class="el" href="group___l3.html#ga56eb193582cf90391b0719f7ec51bde1">fnaddr_t</a> next_hop, int metric, void *entry_data)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function signature for the fwtable interation callback.  <a href="group___f_w_d.html#gad76a3743f2c2e2786f4e1d67967f9ebb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="fish_8h.html#acbb57154d155ec8aec1b8eb08fbf4fc1">neighbor_down_handler_t</a> )(<a class="el" href="group___l3.html#ga56eb193582cf90391b0719f7ec51bde1">fnaddr_t</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The fish_register_neighbor_down_handler registers a function that gets called when a neighbors leaves the network. The function's signature is defined by the type neighbor_down_handler_t. This function is UNRELIABLE. There are many instances where a node is effectivelly down, but hasn't disconnected from the network (e.g., stuck in a tight loop, etc). This callback may be used as an optimization, but not as the only means for detecting neighbor departures. Timeouts must also be used.  <a href="#acbb57154d155ec8aec1b8eb08fbf4fc1"></a><br/></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="fish_8h.html#a336dfcde060146be37d9056f1b30718e">fish_joinnetwork</a> (const char *fishhead_location)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">fish_joinnetwork adds your node to the Fishnet network and is generally the first function you will call.  <a href="#a336dfcde060146be37d9056f1b30718e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="fish_8h.html#a6af801a33b7fc0f2d395e3040f41abcd">fish_joinnetwork_addr</a> (const char *fishhead_location, <a class="el" href="group___l3.html#ga56eb193582cf90391b0719f7ec51bde1">fnaddr_t</a> addr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Like <a class="el" href="fish_8h.html#a336dfcde060146be37d9056f1b30718e" title="fish_joinnetwork adds your node to the Fishnet network and is generally the first...">fish_joinnetwork()</a>, except you can specify a specific L3 address. The function will fails if the address doesn't exist.  <a href="#a6af801a33b7fc0f2d395e3040f41abcd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="fish_8h.html#a16433c3700de4ea987c363ab3d7fe0b8">fish_getheadhost</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">fish_getheadhost can be used to get the name of the fishhead host after fish_joinnetwork has been called.  <a href="#a16433c3700de4ea987c363ab3d7fe0b8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="fish_8h.html#afacc43bd0fe7c87d3cbbbfc0637216b6">fish_getheadport</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">fish_getheadport can be used to get the fishhead port after fish_joinnetwork has been called.  <a href="#afacc43bd0fe7c87d3cbbbfc0637216b6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___l3.html#ga56eb193582cf90391b0719f7ec51bde1">fnaddr_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="fish_8h.html#af5ffdd840c8784e97898fbb3c8aa79d6">fish_getaddress</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">fish_getaddress can be used to get the fishnet node address after fish_joinnetwork has been called.  <a href="#af5ffdd840c8784e97898fbb3c8aa79d6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structfn__l2addr__t.html">fn_l2addr_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="fish_8h.html#a30904f4ae582e7dabd90f84701604977">fish_getl2address</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">fish_getl2address can be used to get the fishnet l2 node address after fish_joinnetwork has been called.  <a href="#a30904f4ae582e7dabd90f84701604977"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___l2.html#ga1fa801f4576bc4ffe79398493a63f697">fish_sendto_l2_builtin</a> (void *l2frame, int mine)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sends a layer 2 frame to all built-in protocol implementations that are interested in it.  <a href="group___l2.html#ga1fa801f4576bc4ffe79398493a63f697"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___l2.html#ga418e3070cc441741aa9435e8c3683b48">fish_sendto_l2_apps</a> (void *l2frame, int mine)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sends a L2 frame to applications that are attached to this node.  <a href="group___l2.html#ga418e3070cc441741aa9435e8c3683b48"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___l3.html#ga62d26bfc7d88690312b270185d0b6dc3">fish_sendto_l3_builtin</a> (void *l3frame, int len, int mine)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sends a L3 frame (including full L3 header) to the libfish built-in protocol implementations.  <a href="group___l3.html#ga62d26bfc7d88690312b270185d0b6dc3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___l3.html#ga394166aceff63db6a684fbfde45781a5">fish_sendto_l3_apps</a> (void *l3frame, int len, int mine)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sends a L3 frame to applications that are attached to this node.  <a href="group___l3.html#ga394166aceff63db6a684fbfde45781a5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="fish_8h.html#a9ca6d35fb7fbe9b3e54a85b61be8f1f8">fish_sendto_l4_builtin</a> (void *l4frame, int len, uint8_t proto, <a class="el" href="group___l3.html#ga56eb193582cf90391b0719f7ec51bde1">fnaddr_t</a> src)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sends a L4 frame (including full L4 header) to the libfish built-in protocol implementations.  <a href="#a9ca6d35fb7fbe9b3e54a85b61be8f1f8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="fish_8h.html#a2cb7416ca1b35166e86dfd9591fe95d2">fish_sendto_l4_apps</a> (void *l4frame, int len, uint8_t proto, <a class="el" href="group___l3.html#ga56eb193582cf90391b0719f7ec51bde1">fnaddr_t</a> src)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sends a L4 frame (including full L4 header) to the application(s) attached to the fishnode.  <a href="#a2cb7416ca1b35166e86dfd9591fe95d2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___l1.html#gaf64a071e28b979742ef6a520198018c9">fish_l1_send</a> (void *frame)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">fish_l1_send sends a L2+ frame through the fishnet overlay.  <a href="group___l1.html#gaf64a071e28b979742ef6a520198018c9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="fish_8h.html#a3268fee39255dddc739984b312a9068f">fish_keybhook</a> (<a class="el" href="fish_8h.html#aa45b58a003ff36d7802685330bff26fb">keyboard_handler</a> keybhandler)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">fish_keybhook registers a function that you write to be called at a later time when a line of keyboard input is available.  <a href="#a3268fee39255dddc739984b312a9068f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="fish_8h.html#ab3b52f80a28ebc1fceceab89bd2b341d">fish_main</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">fish_main is the main fishnet loop. Calling <a class="el" href="fish_8h.html#ab3b52f80a28ebc1fceceab89bd2b341d" title="fish_main is the main fishnet loop. Calling fish_main() is the last thing you should...">fish_main()</a> is the last thing you should do in your main() function.  <a href="#ab3b52f80a28ebc1fceceab89bd2b341d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="fish_8h.html#a98cb744548b782cddab6e5f11d91b9a2">fish_main_exit</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">When fish_main_exit is called fish_main will gracefully finish its current operation and return from fish_main. Use of fish_main_exit allows you to cleanly shut down your fish node. Note that fish_main_exit does *not* cause fish_main to return immediately. You fish node code must return control to libfish before fish_main will return.  <a href="#a98cb744548b782cddab6e5f11d91b9a2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___l3.html#ga25f9373ccce11ba0ffbb6b4ce2c0891e">fish_next_pktid</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the next unique packet ID to be included in the L3 header in host byte order.  <a href="group___l3.html#ga25f9373ccce11ba0ffbb6b4ce2c0891e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="fish_8h.html#a02497580bb9dbdffe44b2eaaefdf9176">event</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="fish_8h.html#a74abdc169914988ce6305ebb06c9553a">fish_scheduleevent</a> (int msec_delay, void(*event_handler)(void *), void *event_handler_argument)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="fish_8h.html#a53c40c876b36eff7f151fd88084f8377">fish_cancelevent</a> (<a class="el" href="fish_8h.html#a02497580bb9dbdffe44b2eaaefdf9176">event</a> event_handle)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">fish_cancelevent cancels a timer before it expires. Its argument is the handle returned by fish_scheduleevent.  <a href="#a53c40c876b36eff7f151fd88084f8377"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__debug.html#gaf789368b248a48b3a62da6271ab53815">fish_setdebuglevel</a> (const int level)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the fishnet debugging level, using the FISH_DEBUG_* constants.  <a href="group__debug.html#gaf789368b248a48b3a62da6271ab53815"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__debug.html#ga71fb76274c0bf11bd7de6f52f5213803">fish_getdebuglevel</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">gets the current fishnet debugging level.  <a href="group__debug.html#ga71fb76274c0bf11bd7de6f52f5213803"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__debug.html#ga2fa1461fe4cf600179ab00fdbcfd4ec9">fish_debug</a> (int level, const char *format,...) __attribute__((format(printf</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate your own debugging message.  <a href="group__debug.html#ga2fa1461fe4cf600179ab00fdbcfd4ec9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__debug.html#gaa5ae19f21ab9ffb954f3f2d31f850e90">fish_debugsupp</a> (int level, const char *format,...) __attribute__((format(printf</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate your own debugging messages without the timestamp.  <a href="group__debug.html#gaa5ae19f21ab9ffb954f3f2d31f850e90"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void void void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__debug.html#gacd932e581b9a4ed16d166ae442b8f4d2">fish_debugchar</a> (int level, char ch)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generates your own debugging message, one character at a time.  <a href="group__debug.html#gacd932e581b9a4ed16d166ae442b8f4d2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__debug.html#gaeaac767f612ef8e64e05934cfc6c61cc">fish_debugframe</a> (int level, const char *msg, const void *frame, int layer, int len, uint8_t l4_protocol)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print a debugging message plus the contents of a frame.  <a href="group__debug.html#gaeaac767f612ef8e64e05934cfc6c61cc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__debug.html#ga45b12915d3bfae2b9e3b3da2e370e02b">fish_setdebugfile</a> (FILE *f)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Select the destination for debugging output.  <a href="group__debug.html#ga45b12915d3bfae2b9e3b3da2e370e02b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___l3.html#gab1075d48bdb9e73744434bc22b3b6818">fn_ntoa</a> (<a class="el" href="group___l3.html#ga56eb193582cf90391b0719f7ec51bde1">fnaddr_t</a> addr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts a L3 address into a printable c-string.  <a href="group___l3.html#gab1075d48bdb9e73744434bc22b3b6818"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___l2.html#ga114eafd3ec0fb43a7d4785c4f3f2932e">fnl2_ntoa</a> (<a class="el" href="structfn__l2addr__t.html">fn_l2addr_t</a> addr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts a L2 address into a printable c-string.  <a href="group___l2.html#ga114eafd3ec0fb43a7d4785c4f3f2932e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___l3.html#ga56eb193582cf90391b0719f7ec51bde1">fnaddr_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___l3.html#ga76232e4f4c7d2b47b7159f6918c532eb">fn_aton</a> (const char *addr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts a c-string L3 address into a fnaddr_t.  <a href="group___l3.html#ga76232e4f4c7d2b47b7159f6918c532eb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="fish_8h.html#a6dc5061181346243b0453698b420fd08">fish_readhook</a> (int sd, void(*read_ready_handler)(int socket))</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">fish_readhook and fish_remove_readhook are advanced functions for integrating ordinary TCP sockets in a fishnet application.  <a href="#a6dc5061181346243b0453698b420fd08"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="fish_8h.html#a748b90d89f5481c5639fc5cd949f93b6">fish_remove_readhook</a> (int sd)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned short&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="fish_8h.html#a852eb2839accabb28d4a4c7d6d0b5232">in_cksum</a> (const void *addr, int byte_len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">in_cksum computes the Internet checksum over the given data. Its implementation and usage is exactly the same as the checksum.c code distributed with previous assignments.  <a href="#a852eb2839accabb28d4a4c7d6d0b5232"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="fish_8h.html#aaa7e57626e19601a8ec419de443e8017">fishsocket_joinnetwork</a> (const char *node, uint32_t layer, uint32_t promisc, <a class="el" href="group___l3.html#ga56eb193582cf90391b0719f7ec51bde1">fnaddr_t</a> dest, uint8_t proto, <a class="el" href="group___l3.html#ga56eb193582cf90391b0719f7ec51bde1">fnaddr_t</a> *addr, <a class="el" href="structfn__l2addr__t.html">fn_l2addr_t</a> *l2addr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Connect to a fishnode from another process. The layer specifies where in the protocol stack the process is connected. Valid values are 2-7. A layer 2 process will send and receive frames that include the L2 header, and so on. Layers 5, 6, and 7 are identical. addr and l2addr are out parameters that provide the process with the address(es) necessary to complete the headers in their part of the frame.  <a href="#aaa7e57626e19601a8ec419de443e8017"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="fish_8h.html#a4a8b30710d0159c0efbb08f668aba52e">fish_enable_neighbor_builtin</a> (int features)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function enables the built-in implementation of the neighbor protocol. This will enable a fishnode to discover all its one-hop neighbors. It must be called after fish_join* and before fish_main. If it is called at any other point in the code it will not work correctly.  <a href="#a4a8b30710d0159c0efbb08f668aba52e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="fish_8h.html#a9dd43634bba195dca8d1d59f3f8592ea">fish_enable_dvrouting_builtin</a> (int features)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function enabled the built-in implementation of the distance vector routing protocol. This routing protocol will discover both neighbors (1-hop) and full L3 routes. It must called after fish_join* and before fish_main. If it is called at any other point in the code it will not work correctly.  <a href="#a9dd43634bba195dca8d1d59f3f8592ea"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="fish_8h.html#af30ec9fd99be41839cc1a19eac2ab447">fish_enable_lsarouting_builtin</a> (int features)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function enables the built-in implementation of the link-state routing protocol. There are currently no features that can be turned on/off, so always pass 0 as the parameter.  <a href="#af30ec9fd99be41839cc1a19eac2ab447"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="fish_8h.html#a0d6fb6027839659205bb4df10c959d5c">fish_register_neighbor_down_handler</a> (<a class="el" href="fish_8h.html#acbb57154d155ec8aec1b8eb08fbf4fc1">neighbor_down_handler_t</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="fish_8h.html#a2db6e2ad4940582f739364ac2ec19cb7">fish_print_neighbor_table</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function prints the contents of the neighbor table maintained by the built-in implementation of the neighbor protocol.  <a href="#a2db6e2ad4940582f739364ac2ec19cb7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_r_p.html#gad60541e12f4ff3940997b6ffa9c303ee">fish_print_arp_table</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function prints the contents of the ARP table maintained by the built-in implementation of ARP.  <a href="group___a_r_p.html#gad60541e12f4ff3940997b6ffa9c303ee"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_w_d.html#ga544a485ea0bf41955e4cd266520c5e97">fish_print_forwarding_table</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function prints the contents of the forwarding table as maintained by the built-in forwarding table.  <a href="group___f_w_d.html#ga544a485ea0bf41955e4cd266520c5e97"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="fish_8h.html#acc5cd11334cdf9b444a429c3134647f2">fish_print_dv_state</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function prints the state maintained as part of the built-in distance vector implementation.  <a href="#acc5cd11334cdf9b444a429c3134647f2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="fish_8h.html#a91e5018dd53bdbae46ab6844796f6869">fish_print_lsa_topo</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function prints the LSA's internal view of the fishnet topology.  <a href="#a91e5018dd53bdbae46ab6844796f6869"></a><br/></td></tr>
<tr><td colspan="2"><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structfn__l2addr__t.html">fn_l2addr_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___l2.html#ga2df87dd135076789b17a5166d2b5e4fc">ALL_L2_NEIGHBORS</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A global that holds the L2 broadcast address.  <a href="group___l2.html#ga2df87dd135076789b17a5166d2b5e4fc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="struct_fishnet_l2_funcs.html">FishnetL2Funcs</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___l2.html#gace8427af2028b1c5e79bfa46b65624e6">fish_l2</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Functions for transmitting and receiving L2 frames.  <a href="group___l2.html#gace8427af2028b1c5e79bfa46b65624e6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="struct_fishnet_l3_funcs.html">FishnetL3Funcs</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___l3.html#ga62401265a634aaba1923d6edf6b94842">fish_l3</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Functions for sending and receiving layer 3 frames.  <a href="group___l3.html#ga62401265a634aaba1923d6edf6b94842"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="struct_fishnet_l4_funcs.html">FishnetL4Funcs</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="fish_8h.html#ada8e1612b1080830b758aa5d7366593d">fish_l4</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Layer 4 frame handling functions.  <a href="#ada8e1612b1080830b758aa5d7366593d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structfishnet__arp__functions.html">fishnet_arp_functions</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_r_p.html#gaae010e0d6fe3eb5ce01ad407125e71a5">fish_arp</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Functions for interacting with the ARP cache and resolving L3 addresses into L2 addresses.  <a href="group___a_r_p.html#gaae010e0d6fe3eb5ce01ad407125e71a5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structfishnet__fwtable__functions.html">fishnet_fwtable_functions</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_w_d.html#gada0880c23fd16c350788f3b06ea2aa6b">fish_fwd</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A structure that contains function pointers for all fowarding table operations, such as lookup and insertion.  <a href="group___f_w_d.html#gada0880c23fd16c350788f3b06ea2aa6b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structfishnet__fcmp__functions.html">fishnet_fcmp_functions</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_c_m_p.html#gaf3ecb8488f8b12e300d6e4a8250878ab">fish_fcmp</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A structure that contains function pointers for all FCMP related operations.  <a href="group___f_c_m_p.html#gaf3ecb8488f8b12e300d6e4a8250878ab"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structfishnet__name__functions.html">fishnet_name_functions</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="fish_8h.html#aeeb080347f28105642a9dc5727d4f439">fish_name</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Functions and declarations that interact with the built-in name protocol implementation. Modifing these function pointers allows you to provide your own implementation.  <a href="#aeeb080347f28105642a9dc5727d4f439"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structfishnet__lsa__functions.html">fishnet_lsa_functions</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="fish_8h.html#af27b374c88ac5a3cfaf8b340216c3ede">fish_lsa</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The LSA implementation is current incomplete! Functions, structures, and constants that relate to the built-in implementation of the link state routing algorithm.  <a href="#af27b374c88ac5a3cfaf8b340216c3ede"></a><br/></td></tr>
</table>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="a1dff069634154ca489b6912fc961da79"></a><!-- doxytag: member="fish.h::DVROUTING_KEEP_ROUTE_HISTORY" ref="a1dff069634154ca489b6912fc961da79" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DVROUTING_KEEP_ROUTE_HISTORY&nbsp;&nbsp;&nbsp;0x10</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enables route history in the built-in dv implementation. Non-optimal routes are kept as "backups" in case the primary route fails. This option tends to speed route convergance when there is churn in the network. </p>

<p>Definition at line <a class="el" href="fish_8h_source.html#l01205">1205</a> of file <a class="el" href="fish_8h_source.html">fish.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa4f1786ab3107fd95c808f6b4be105e6"></a><!-- doxytag: member="fish.h::DVROUTING_SPLIT_HOR_POISON_REV" ref="aa4f1786ab3107fd95c808f6b4be105e6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DVROUTING_SPLIT_HOR_POISON_REV&nbsp;&nbsp;&nbsp;0x08</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enable split horizion with poison reverse. Using this option increases resiliency against counting to infinity problems, but also increases the amount of routing traffic on the network. </p>

<p>Definition at line <a class="el" href="fish_8h_source.html#l01199">1199</a> of file <a class="el" href="fish_8h_source.html">fish.h</a>.</p>

</div>
</div>
<a class="anchor" id="a9da208c5068204dc49fa6c59eef27718"></a><!-- doxytag: member="fish.h::DVROUTING_TRIGGERED_UPDATES" ref="a9da208c5068204dc49fa6c59eef27718" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DVROUTING_TRIGGERED_UPDATES&nbsp;&nbsp;&nbsp;0x01</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If present, enable triggered updates in the built-in implementation. Triggered updates create a much higher network load, especially in larger networks. They can also make it hard to follow what is happening since the updates fly by quickly. Passing a value of 0 disables triggered updates. Passing any other value enables them. </p>

<p>Definition at line <a class="el" href="fish_8h_source.html#l01177">1177</a> of file <a class="el" href="fish_8h_source.html">fish.h</a>.</p>

</div>
</div>
<a class="anchor" id="a10b5eaf044a18b5feb88127f077266b3"></a><!-- doxytag: member="fish.h::DVROUTING_WITHDRAW_ROUTES" ref="a10b5eaf044a18b5feb88127f077266b3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DVROUTING_WITHDRAW_ROUTES&nbsp;&nbsp;&nbsp;0x02</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If present, enable route withdraws. When using route withdraws, the dv code will advertise all withdrawn route with a metric of infinity. If route withdraws are not used then invalid routes will immediately leave the dv state. </p>

<p>Definition at line <a class="el" href="fish_8h_source.html#l01184">1184</a> of file <a class="el" href="fish_8h_source.html">fish.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa93f0eb578d23995850d61f7d61c55c1"></a><!-- doxytag: member="fish.h::FALSE" ref="aa93f0eb578d23995850d61f7d61c55c1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FALSE&nbsp;&nbsp;&nbsp;(0)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="fish_8h_source.html#l01299">1299</a> of file <a class="el" href="fish_8h_source.html">fish.h</a>.</p>

</div>
</div>
<a class="anchor" id="af580f1123d8e17a73f75aae203601d68"></a><!-- doxytag: member="fish.h::IPTR_FMT" ref="af580f1123d8e17a73f75aae203601d68" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IPTR_FMT&nbsp;&nbsp;&nbsp;&quot;d&quot;</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="fish_8h_source.html#l00020">20</a> of file <a class="el" href="fish_8h_source.html">fish.h</a>.</p>

</div>
</div>
<a class="anchor" id="a95423e01c84b7e7d0833542a9029790a"></a><!-- doxytag: member="fish.h::NEIGHBOR_USE_LIBFISH_NEIGHBOR_DOWN" ref="a95423e01c84b7e7d0833542a9029790a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NEIGHBOR_USE_LIBFISH_NEIGHBOR_DOWN&nbsp;&nbsp;&nbsp;0x01</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Permits the built-in neighbor protocol to use the "neighbor down" information provided by libfish. This is the exact same information provided to the 'neighbor_down_handler_t' as documented below. This option does not impact discovering neighbors. That still takes place via broadcast frames as described in the fishnet spec. Use of this option causes most (but not all) neighbor departures to be detected immediately. Not using this option requires a full timeout before detecting a neighbor has left the network. </p>

<p>Definition at line <a class="el" href="fish_8h_source.html#l01160">1160</a> of file <a class="el" href="fish_8h_source.html">fish.h</a>.</p>

</div>
</div>
<a class="anchor" id="a5918fd6126ce72175c6cef916484eba6"></a><!-- doxytag: member="fish.h::RVROUTING_USE_LIBFISH_NEIGHBOR_DOWN" ref="a5918fd6126ce72175c6cef916484eba6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RVROUTING_USE_LIBFISH_NEIGHBOR_DOWN&nbsp;&nbsp;&nbsp;0x04</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Permits the built-in dv routing solution to use the "neighbor down" information provided by libfish. This is the exact same information provided to the 'neighbor_down_handler_t' as documented below. This option does not impact discovering neighbors. That still takes place via DV frames as described in the fishnet spec. Use of this option causes most (but not all) neighbor departures to be detected immediately. Not using this option requires a full timeout before detecting a neighbor has left the network. </p>

<p>Definition at line <a class="el" href="fish_8h_source.html#l01194">1194</a> of file <a class="el" href="fish_8h_source.html">fish.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa8cecfc5c5c054d2875c03e77b7be15d"></a><!-- doxytag: member="fish.h::TRUE" ref="aa8cecfc5c5c054d2875c03e77b7be15d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TRUE&nbsp;&nbsp;&nbsp;(!FALSE)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="fish_8h_source.html#l01302">1302</a> of file <a class="el" href="fish_8h_source.html">fish.h</a>.</p>

</div>
</div>
<a class="anchor" id="aff3dbff84d5ac014bdbe6d62a4541b7a"></a><!-- doxytag: member="fish.h::UIPTR_FMT" ref="aff3dbff84d5ac014bdbe6d62a4541b7a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UIPTR_FMT&nbsp;&nbsp;&nbsp;&quot;u&quot;</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="fish_8h_source.html#l00021">21</a> of file <a class="el" href="fish_8h_source.html">fish.h</a>.</p>

</div>
</div>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="a02497580bb9dbdffe44b2eaaefdf9176"></a><!-- doxytag: member="fish.h::event" ref="a02497580bb9dbdffe44b2eaaefdf9176" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef intptr_t <a class="el" href="fish_8h.html#a02497580bb9dbdffe44b2eaaefdf9176">event</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="fish_8h_source.html#l00655">655</a> of file <a class="el" href="fish_8h_source.html">fish.h</a>.</p>

</div>
</div>
<a class="anchor" id="afb544cef80537f1a18297eda61234a2b"></a><!-- doxytag: member="fish.h::event_handler_t" ref="afb544cef80537f1a18297eda61234a2b" args=")(void *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* <a class="el" href="fish_8h.html#afb544cef80537f1a18297eda61234a2b">event_handler_t</a>)(void *)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>fish_scheduleevent sets up a timer function to be called at some time in the future. </p>
<p>You write the timer function, and supply an argument value that it will be invoked with. fish_scheduleevent returns a handle to the timer event, which can be used to cancel it before it expires. The return value is an integer representing the event, which will always be greater than 0.</p>
<p>Note that attempting to schedule two events with the same event_handler and argument will result in an error. </p>

<p>Definition at line <a class="el" href="fish_8h_source.html#l00654">654</a> of file <a class="el" href="fish_8h_source.html">fish.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa45b58a003ff36d7802685330bff26fb"></a><!-- doxytag: member="fish.h::keyboard_handler" ref="aa45b58a003ff36d7802685330bff26fb" args=")(char *line_of_text)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* <a class="el" href="fish_8h.html#aa45b58a003ff36d7802685330bff26fb">keyboard_handler</a>)(char *line_of_text)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>keyboard_handler is the type of the upcall registered with <a class="el" href="fish_8h.html#a3268fee39255dddc739984b312a9068f" title="fish_keybhook registers a function that you write to be called at a later time when...">fish_keybhook()</a>. Your keyboard input handler will take one parameter: *line_of_text*, which does not include the newline character ('<br/>
'), but is null-terminated so that functions like sprintf will work. </p>

<p>Definition at line <a class="el" href="fish_8h_source.html#l00136">136</a> of file <a class="el" href="fish_8h_source.html">fish.h</a>.</p>

</div>
</div>
<a class="anchor" id="acbb57154d155ec8aec1b8eb08fbf4fc1"></a><!-- doxytag: member="fish.h::neighbor_down_handler_t" ref="acbb57154d155ec8aec1b8eb08fbf4fc1" args=")(fnaddr_t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* <a class="el" href="fish_8h.html#acbb57154d155ec8aec1b8eb08fbf4fc1">neighbor_down_handler_t</a>)(<a class="el" href="group___l3.html#ga56eb193582cf90391b0719f7ec51bde1">fnaddr_t</a>)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The fish_register_neighbor_down_handler registers a function that gets called when a neighbors leaves the network. The function's signature is defined by the type neighbor_down_handler_t. This function is UNRELIABLE. There are many instances where a node is effectivelly down, but hasn't disconnected from the network (e.g., stuck in a tight loop, etc). This callback may be used as an optimization, but not as the only means for detecting neighbor departures. Timeouts must also be used. </p>
<p>Passing NULL as the only argument to fish_register_neighbor_down_handler will disable the callback. </p>

<p>Definition at line <a class="el" href="fish_8h_source.html#l01259">1259</a> of file <a class="el" href="fish_8h_source.html">fish.h</a>.</p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a53c40c876b36eff7f151fd88084f8377"></a><!-- doxytag: member="fish.h::fish_cancelevent" ref="a53c40c876b36eff7f151fd88084f8377" args="(event event_handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* fish_cancelevent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fish_8h.html#a02497580bb9dbdffe44b2eaaefdf9176">event</a>&nbsp;</td>
          <td class="paramname"> <em>event_handle</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>fish_cancelevent cancels a timer before it expires. Its argument is the handle returned by fish_scheduleevent. </p>

</div>
</div>
<a class="anchor" id="a9dd43634bba195dca8d1d59f3f8592ea"></a><!-- doxytag: member="fish.h::fish_enable_dvrouting_builtin" ref="a9dd43634bba195dca8d1d59f3f8592ea" args="(int features)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fish_enable_dvrouting_builtin </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>features</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function enabled the built-in implementation of the distance vector routing protocol. This routing protocol will discover both neighbors (1-hop) and full L3 routes. It must called after fish_join* and before fish_main. If it is called at any other point in the code it will not work correctly. </p>
<p>"features" is a bit field composed by bit-wise or-ing any of the feature flags together. This enables you to test the behavior with and without optimizations in place. Available features are: </p>

</div>
</div>
<a class="anchor" id="af30ec9fd99be41839cc1a19eac2ab447"></a><!-- doxytag: member="fish.h::fish_enable_lsarouting_builtin" ref="af30ec9fd99be41839cc1a19eac2ab447" args="(int features)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fish_enable_lsarouting_builtin </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>features</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function enables the built-in implementation of the link-state routing protocol. There are currently no features that can be turned on/off, so always pass 0 as the parameter. </p>

</div>
</div>
<a class="anchor" id="a4a8b30710d0159c0efbb08f668aba52e"></a><!-- doxytag: member="fish.h::fish_enable_neighbor_builtin" ref="a4a8b30710d0159c0efbb08f668aba52e" args="(int features)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fish_enable_neighbor_builtin </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>features</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function enables the built-in implementation of the neighbor protocol. This will enable a fishnode to discover all its one-hop neighbors. It must be called after fish_join* and before fish_main. If it is called at any other point in the code it will not work correctly. </p>

</div>
</div>
<a class="anchor" id="af5ffdd840c8784e97898fbb3c8aa79d6"></a><!-- doxytag: member="fish.h::fish_getaddress" ref="af5ffdd840c8784e97898fbb3c8aa79d6" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___l3.html#ga56eb193582cf90391b0719f7ec51bde1">fnaddr_t</a> fish_getaddress </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>fish_getaddress can be used to get the fishnet node address after fish_joinnetwork has been called. </p>

</div>
</div>
<a class="anchor" id="a16433c3700de4ea987c363ab3d7fe0b8"></a><!-- doxytag: member="fish.h::fish_getheadhost" ref="a16433c3700de4ea987c363ab3d7fe0b8" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* fish_getheadhost </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>fish_getheadhost can be used to get the name of the fishhead host after fish_joinnetwork has been called. </p>

</div>
</div>
<a class="anchor" id="afacc43bd0fe7c87d3cbbbfc0637216b6"></a><!-- doxytag: member="fish.h::fish_getheadport" ref="afacc43bd0fe7c87d3cbbbfc0637216b6" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fish_getheadport </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>fish_getheadport can be used to get the fishhead port after fish_joinnetwork has been called. </p>

</div>
</div>
<a class="anchor" id="a30904f4ae582e7dabd90f84701604977"></a><!-- doxytag: member="fish.h::fish_getl2address" ref="a30904f4ae582e7dabd90f84701604977" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structfn__l2addr__t.html">fn_l2addr_t</a> fish_getl2address </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>fish_getl2address can be used to get the fishnet l2 node address after fish_joinnetwork has been called. </p>

</div>
</div>
<a class="anchor" id="a336dfcde060146be37d9056f1b30718e"></a><!-- doxytag: member="fish.h::fish_joinnetwork" ref="a336dfcde060146be37d9056f1b30718e" args="(const char *fishhead_location)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fish_joinnetwork </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fishhead_location</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>fish_joinnetwork adds your node to the Fishnet network and is generally the first function you will call. </p>
<p>The host and port arguments describe the fishhead to contact, which is synonymous with the network that you are joining. If the fishhead_location is not "", then a fishhead node is contacted for obtaining the network topology. If the fishhead_location is "", then the network topology is dictated by the physical environment (this is typically used for wireless).</p>
<p>You may optionally supply your requested node address.</p>
<p>The call will either succeed, in which case you have joined a Fishnet, or will fail, printing an error message and exiting. There are a variety of possible errors, such as not being able to contact the fishhead or the address you wanted already being in use.</p>
<p>Note that this function will exit the program on failure. </p>

</div>
</div>
<a class="anchor" id="a6af801a33b7fc0f2d395e3040f41abcd"></a><!-- doxytag: member="fish.h::fish_joinnetwork_addr" ref="a6af801a33b7fc0f2d395e3040f41abcd" args="(const char *fishhead_location, fnaddr_t addr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fish_joinnetwork_addr </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fishhead_location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___l3.html#ga56eb193582cf90391b0719f7ec51bde1">fnaddr_t</a>&nbsp;</td>
          <td class="paramname"> <em>addr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Like <a class="el" href="fish_8h.html#a336dfcde060146be37d9056f1b30718e" title="fish_joinnetwork adds your node to the Fishnet network and is generally the first...">fish_joinnetwork()</a>, except you can specify a specific L3 address. The function will fails if the address doesn't exist. </p>

</div>
</div>
<a class="anchor" id="a3268fee39255dddc739984b312a9068f"></a><!-- doxytag: member="fish.h::fish_keybhook" ref="a3268fee39255dddc739984b312a9068f" args="(keyboard_handler keybhandler)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fish_keybhook </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fish_8h.html#aa45b58a003ff36d7802685330bff26fb">keyboard_handler</a>&nbsp;</td>
          <td class="paramname"> <em>keybhandler</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>fish_keybhook registers a function that you write to be called at a later time when a line of keyboard input is available. </p>
<p>Like recvhook, it is an upcall that gets called from inside fish_main. It can do anything it likes with the input, but must return before further input can be received.</p>
<p>Note that the memory in which the input is stored belongs to libfish; you MUST NOT free it. </p>

</div>
</div>
<a class="anchor" id="ab3b52f80a28ebc1fceceab89bd2b341d"></a><!-- doxytag: member="fish.h::fish_main" ref="ab3b52f80a28ebc1fceceab89bd2b341d" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fish_main </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>fish_main is the main fishnet loop. Calling <a class="el" href="fish_8h.html#ab3b52f80a28ebc1fceceab89bd2b341d" title="fish_main is the main fishnet loop. Calling fish_main() is the last thing you should...">fish_main()</a> is the last thing you should do in your main() function. </p>
<p>Your program will typically join a Fishnet, set up receive and keyboard handlers, plus any timers, and then sit in <a class="el" href="fish_8h.html#ab3b52f80a28ebc1fceceab89bd2b341d" title="fish_main is the main fishnet loop. Calling fish_main() is the last thing you should...">fish_main()</a> for the rest of the program. Frame reception, keyboard input and timer expiry are called from within <a class="el" href="fish_8h.html#ab3b52f80a28ebc1fceceab89bd2b341d" title="fish_main is the main fishnet loop. Calling fish_main() is the last thing you should...">fish_main()</a> and return control to <a class="el" href="fish_8h.html#ab3b52f80a28ebc1fceceab89bd2b341d" title="fish_main is the main fishnet loop. Calling fish_main() is the last thing you should...">fish_main()</a>.</p>
<p>fish_main will automatically exit the program when the user types "exit". </p>

</div>
</div>
<a class="anchor" id="a98cb744548b782cddab6e5f11d91b9a2"></a><!-- doxytag: member="fish.h::fish_main_exit" ref="a98cb744548b782cddab6e5f11d91b9a2" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fish_main_exit </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>When fish_main_exit is called fish_main will gracefully finish its current operation and return from fish_main. Use of fish_main_exit allows you to cleanly shut down your fish node. Note that fish_main_exit does *not* cause fish_main to return immediately. You fish node code must return control to libfish before fish_main will return. </p>

</div>
</div>
<a class="anchor" id="acc5cd11334cdf9b444a429c3134647f2"></a><!-- doxytag: member="fish.h::fish_print_dv_state" ref="acc5cd11334cdf9b444a429c3134647f2" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fish_print_dv_state </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function prints the state maintained as part of the built-in distance vector implementation. </p>

</div>
</div>
<a class="anchor" id="a91e5018dd53bdbae46ab6844796f6869"></a><!-- doxytag: member="fish.h::fish_print_lsa_topo" ref="a91e5018dd53bdbae46ab6844796f6869" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fish_print_lsa_topo </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function prints the LSA's internal view of the fishnet topology. </p>

</div>
</div>
<a class="anchor" id="a2db6e2ad4940582f739364ac2ec19cb7"></a><!-- doxytag: member="fish.h::fish_print_neighbor_table" ref="a2db6e2ad4940582f739364ac2ec19cb7" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fish_print_neighbor_table </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function prints the contents of the neighbor table maintained by the built-in implementation of the neighbor protocol. </p>

</div>
</div>
<a class="anchor" id="a6dc5061181346243b0453698b420fd08"></a><!-- doxytag: member="fish.h::fish_readhook" ref="a6dc5061181346243b0453698b420fd08" args="(int sd, void(*read_ready_handler)(int socket))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fish_readhook </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>sd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(int socket)&nbsp;</td>
          <td class="paramname"> <em>read_ready_handler</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>fish_readhook and fish_remove_readhook are advanced functions for integrating ordinary TCP sockets in a fishnet application. </p>
<p>read_ready_handler is called when socket is ready to be read. Usually, this means there is data to be read, but sometimes the socket may have been closed by the other end, meaning that read() will return zero bytes.</p>
<p>remove_readhook should be called when the socket is closed, otherwise you may see "bad file descriptor" errors. </p>

</div>
</div>
<a class="anchor" id="a0d6fb6027839659205bb4df10c959d5c"></a><!-- doxytag: member="fish.h::fish_register_neighbor_down_handler" ref="a0d6fb6027839659205bb4df10c959d5c" args="(neighbor_down_handler_t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fish_register_neighbor_down_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fish_8h.html#acbb57154d155ec8aec1b8eb08fbf4fc1">neighbor_down_handler_t</a>&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a748b90d89f5481c5639fc5cd949f93b6"></a><!-- doxytag: member="fish.h::fish_remove_readhook" ref="a748b90d89f5481c5639fc5cd949f93b6" args="(int sd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fish_remove_readhook </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>sd</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a74abdc169914988ce6305ebb06c9553a"></a><!-- doxytag: member="fish.h::fish_scheduleevent" ref="a74abdc169914988ce6305ebb06c9553a" args="(int msec_delay, void(*event_handler)(void *), void *event_handler_argument)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="fish_8h.html#a02497580bb9dbdffe44b2eaaefdf9176">event</a> fish_scheduleevent </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>msec_delay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *)&nbsp;</td>
          <td class="paramname"> <em>event_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>event_handler_argument</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a2cb7416ca1b35166e86dfd9591fe95d2"></a><!-- doxytag: member="fish.h::fish_sendto_l4_apps" ref="a2cb7416ca1b35166e86dfd9591fe95d2" args="(void *l4frame, int len, uint8_t proto, fnaddr_t src)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fish_sendto_l4_apps </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>l4frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>proto</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___l3.html#ga56eb193582cf90391b0719f7ec51bde1">fnaddr_t</a>&nbsp;</td>
          <td class="paramname"> <em>src</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sends a L4 frame (including full L4 header) to the application(s) attached to the fishnode. </p>
<p>This must be used in the order depicted in the flow chart above. </p>

</div>
</div>
<a class="anchor" id="a9ca6d35fb7fbe9b3e54a85b61be8f1f8"></a><!-- doxytag: member="fish.h::fish_sendto_l4_builtin" ref="a9ca6d35fb7fbe9b3e54a85b61be8f1f8" args="(void *l4frame, int len, uint8_t proto, fnaddr_t src)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fish_sendto_l4_builtin </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>l4frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>proto</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___l3.html#ga56eb193582cf90391b0719f7ec51bde1">fnaddr_t</a>&nbsp;</td>
          <td class="paramname"> <em>src</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sends a L4 frame (including full L4 header) to the libfish built-in protocol implementations. </p>
<p>This must be used in the order depicted in the flow chart above. This function returns true if the frame was "consumed" and should not be processed further. If the function returns false then further processing is needed. </p>

</div>
</div>
<a class="anchor" id="aaa7e57626e19601a8ec419de443e8017"></a><!-- doxytag: member="fish.h::fishsocket_joinnetwork" ref="aaa7e57626e19601a8ec419de443e8017" args="(const char *node, uint32_t layer, uint32_t promisc, fnaddr_t dest, uint8_t proto, fnaddr_t *addr, fn_l2addr_t *l2addr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fishsocket_joinnetwork </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>promisc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___l3.html#ga56eb193582cf90391b0719f7ec51bde1">fnaddr_t</a>&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>proto</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___l3.html#ga56eb193582cf90391b0719f7ec51bde1">fnaddr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfn__l2addr__t.html">fn_l2addr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>l2addr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Connect to a fishnode from another process. The layer specifies where in the protocol stack the process is connected. Valid values are 2-7. A layer 2 process will send and receive frames that include the L2 header, and so on. Layers 5, 6, and 7 are identical. addr and l2addr are out parameters that provide the process with the address(es) necessary to complete the headers in their part of the frame. </p>

</div>
</div>
<a class="anchor" id="a852eb2839accabb28d4a4c7d6d0b5232"></a><!-- doxytag: member="fish.h::in_cksum" ref="a852eb2839accabb28d4a4c7d6d0b5232" args="(const void *addr, int byte_len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned short in_cksum </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>byte_len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>in_cksum computes the Internet checksum over the given data. Its implementation and usage is exactly the same as the checksum.c code distributed with previous assignments. </p>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="ada8e1612b1080830b758aa5d7366593d"></a><!-- doxytag: member="fish.h::fish_l4" ref="ada8e1612b1080830b758aa5d7366593d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="struct_fishnet_l4_funcs.html">FishnetL4Funcs</a>  <a class="el" href="fish_8h.html#ada8e1612b1080830b758aa5d7366593d">fish_l4</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Layer 4 frame handling functions. </p>
<p>The functions in the fish_l4 structure can be overridden by providing pointers to your own implementation. The remaining functions can not be overridden. </p>

</div>
</div>
<a class="anchor" id="af27b374c88ac5a3cfaf8b340216c3ede"></a><!-- doxytag: member="fish.h::fish_lsa" ref="af27b374c88ac5a3cfaf8b340216c3ede" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structfishnet__lsa__functions.html">fishnet_lsa_functions</a>  <a class="el" href="fish_8h.html#af27b374c88ac5a3cfaf8b340216c3ede">fish_lsa</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The LSA implementation is current incomplete! Functions, structures, and constants that relate to the built-in implementation of the link state routing algorithm. </p>

</div>
</div>
<a class="anchor" id="aeeb080347f28105642a9dc5727d4f439"></a><!-- doxytag: member="fish.h::fish_name" ref="aeeb080347f28105642a9dc5727d4f439" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structfishnet__name__functions.html">fishnet_name_functions</a>  <a class="el" href="fish_8h.html#aeeb080347f28105642a9dc5727d4f439">fish_name</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Functions and declarations that interact with the built-in name protocol implementation. Modifing these function pointers allows you to provide your own implementation. </p>

</div>
</div>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 14 Jan 2014 for Fishnet by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
